# -*- coding: utf-8 -*-
"""PiDay.ipynb의 사본

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n092fjwQtBGOyOholzv_hGHs17Yz7r3v

# Globular Cluster N-body simulation

Maria Okounkova (mokounkova@pasadena.edu)

This is an n-body simulation code using Newton's laws of gravity, which can be used to model dynamics of stars in globular clusters, for example.

This is adapted from the "Create Your Own N-body Simulation (With Python)" [code](https://medium.com/swlh/create-your-own-n-body-simulation-with-python-f417234885e9) by Philip Mocz (2020)

### Step 1: Import the libraries for our computation!
"""

from matplotlib import rc
rc('animation', html='jshtml')
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

"""### Step 2: The physics

Computing accelerations in a *function* using Newton's laws
"""

def getAcc(pos, mass, G):
	"""
  Calculate the acceleration on each particle due to Newton's Law
	pos is an N x 3 matrix of positions
	mass is an N x 1 vector of masses
	G is Newton's Gravitational constant
	"""

	# positions r = [x,y,z] for all particles
	x = pos[:,0:1]
	y = pos[:,1:2]
	z = pos[:,2:3]

	# matrix that stores all pairwise particle separations: r_j - r_i
	dx = x.T - x
	dy = y.T - y
	dz = z.T - z

	# matrix that stores 1/r^3 for all particle pairwise particle separations
	softening = 0.1 # softening length
	inv_r3 = (dx**2 + dy**2 + dz**2 + softening**2)
	inv_r3[inv_r3>0] = inv_r3[inv_r3>0]**(-1.5)

	acc_x = G * (dx * inv_r3) @ mass
	acc_y = G * (dy * inv_r3) @ mass
	acc_z = G * (dz * inv_r3) @ mass

	# pack together the acceleration components
	acc = np.hstack((acc_x,acc_y,acc_z))

	return acc

"""### Step 3: Simulation parameters ⭐ Play around with these after! ⭐"""

# Number of particles
N = 15
# Total mass of the system
total_mass = 20.0
# End time of the simulation
tEnd = 2.0
# Timestep
dt = 0.01
# Newton's constant
G = 1.0

"""### Step 4: Run the simulation
Use the initial conditions from the cell above to run our simulation!
"""

# Number of timesteps
Nt = int(np.ceil(tEnd/dt))

# Particle masses, evenly distributed
# Can change this for more advanced simulations
mass = total_mass*np.ones((N,1))/N

# Initial time, positions, and velocities
t = 0
pos = np.random.randn(N,3)
vel = np.random.randn(N,3)

# Convert to Center-of-Mass frame
vel -= np.mean(mass * vel,0) / np.mean(mass)

# calculate initial gravitational accelerations
acc = getAcc(pos, mass, G)

# Save positions for plotting trails
pos_save = np.zeros((N,3,Nt+1))
pos_save[:,:,0] = pos

# Simulation Main Loop
def simulate(i):

    # Prepare figure
    ax.clear()
    ax.set(xlim=(-2, 2), ylim=(-2, 2))
    ax.set_aspect('equal', 'box')
    ax.set_facecolor('black')
    ax.set_xlabel('X position')
    ax.set_ylabel('Y position')

    global t, acc, vel, pos

    # (1/2) kick
    vel += acc * dt/2.0
    # drift
    pos += vel * dt
    # update accelerations
    acc = getAcc(pos, mass, G)
    # (1/2) kick
    vel += acc * dt/2.0
    # update time
    t += dt

    # save positions for plotting trail
    pos_save[:,:,i+1] = pos

    # plot the positions and trails
    xx = pos_save[:,0,max(i-50,0):i+1]
    yy = pos_save[:,1,max(i-50,0):i+1]
    ax.scatter(xx,yy,s=1.0,color='#6b6a68')
    ax.scatter(pos[:,0],pos[:,1],s=10,color='#cbde3a')

# Visualization figure
fig, ax = plt.subplots(1, figsize=(8,8))
animation.FuncAnimation(fig, simulate, frames = Nt, blit=False, repeat=True)

